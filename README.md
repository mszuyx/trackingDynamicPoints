# Tracking Dynamic Points

This document outlines a robust and efficient pipeline for detecting moving objects using a 2D LiDAR scanner on a moving robot. The process includes point cloud prediction, registration, and filtering techniques to isolate dynamic objects.

## Variables and Definitions

- **P_c**: Current frame point cloud.
- **v**: Robot's velocity vector, including both translation and rotation.
- **T(v)**: Transformation matrix derived from the robot's velocity vector v, used to project the current frame to the next frame.
- **P_p**: Predicted point cloud for the next frame, generated by transforming P_c using T(v).
- **P_a**: Actual point cloud from the next frame, collected by the LiDAR scanner.
- **d(p_a, p_p)**: Distance metric between a point p_a in P_a and a point p_p in P_p, typically Euclidean distance.
- **epsilon**: Threshold distance used in matching points to determine if a point in P_a corresponds to a point in P_p.
- **ICP(P_a, P_p)**: Iterative Closest Point algorithm, used to align P_a with P_p by minimizing the difference between them.
- **BBox**: Bounding box that defines the spatial limits within which the points of P_p are retained.
- **r**: Radius used in the radius outlier removal filter to define the neighborhood of each point.
- **k**: Minimum number of neighbors a point must have within the radius r to be retained.
- **Static Points**: Set of points in P_a that match closely with points in P_p and are considered static relative to the robot.
- **Dynamic Points**: Set of points in P_a that do not match closely with points in P_p and are considered dynamic (likely to be moving objects).


## Steps in the Pipeline

### 1. Prediction of the Next Frame Point Cloud
```pseudo
P_p = transform(P_c, T(v))
```
Compute the predicted point cloud `P_p` by applying the transformation `T(v)` to the current point cloud `P_c`.

### 2. Bounding Box Cropping
```pseudo
P_p = crop_to_bounding_box(P_p, BBox)
```
Crop `P_p` to retain only the points within the bounding box `BBox`.

### 3. Registration of the Actual Next Frame
```pseudo
P_a' = ICP(P_a, P_p)
```
Align the actual next frame point cloud `P_a` with `P_p` using ICP.

### 4. Matching Points (Static)
```pseudo
Static_Points = find_matching_points(P_a, P_p, epsilon)
```
Identify points in `P_a` that match closely with points in `P_p` within threshold `epsilon`.

### 5. Non-Matching Points (Dynamic)
```pseudo
Dynamic_Points = P_a - Static_Points
```
The remaining points in `P_a` are considered dynamic.

### 7. Radius Outlier Removal on Dynamic Points
```pseudo
Dynamic_Points = radius_outlier_removal(Dynamic_Points, r, k)
```
Apply radius outlier removal to the dynamic points to eliminate noise and small clusters.
